/**
 * FEASST - Free Energy and Advanced Sampling Simulation Toolkit
 * http://pages.nist.gov/feasst, National Institute of Standards and Technology
 * Harold W. Hatch, harold.hatch@nist.gov
 *
 * Permission to use this data/software is contingent upon your acceptance of
 * the terms of LICENSE.txt and upon your providing
 * appropriate acknowledgments of NIST's creation of the data/software.
 */

#include "pair_hard_sphere.h"
#include "mc.h"
#include "trial_delete.h"
#include "trial_xswap.h"

int main() {  // HardSphere, POLYDISPERSE

  int nMolMax = 300, nMolMin = 0, nfreq = 1e5, ncfreq = 1e6;
  int64_t npr = 8000000000;
  double rCut = 3., beta = 1./5., activ = exp(-4.568214), boxl = 12;
  std::stringstream addMolTypeA, addMolTypeB;

  feasst::ranInitByDate();
  feasst::Space space(3);
  s.lset(12);

  feasst::PairHardSphere p(&s);
  for (int iMol = 1; iMol <= nMolMax; ++iMol) {
    std::stringstream addMolType;
    addMolType << s.install_dir() << "/forcefield/data.atom" << iMol;
    s.addMolInit(addMolType.str().c_str());
    p.initData(addMolType.str().c_str());
  }

  // generate random sigmas
  vector<double> sigvec;
  const double sigFrac = 0.4492;
  const double sigMin = 1., sigMax = sigMin/sigFrac;
  //vector<double> eps;
  for (int iType = 0; iType < int(p.eps().size()); ++iType) {
//    cout << "iType " << iType << endl;
    int nSigTries = 0, nSigTriesMax = 1e4;
    double sig = -1;
    while (nSigTries >= 0 && nSigTries < nSigTriesMax) {
      sig = sigMin + (sigMax - sigMin)*p.uniformRanNum();
      if (p.uniformRanNum() < pow(1/sig, 3.)) {
        nSigTries = -1;
      } else {
        ++nSigTries;
      }
    }
    cout << "nSigTries " << nSigTries << endl;
    ASSERT(nSigTries == -1, "Polydisperse failed, increase nSigTriesMax.");
    sigvec.push_back(sig);
    //sigvec.push_back(p.gaussRanNum(0.2, 1));
    //eps.push_back(p.eps()[iType]);
  }
//  sig[2] = -1;
  p.initPairParam(p.eps(), sigvec);
  //p.initPairParam(eps, sig);
  //s.addMolInit(addMolTypeB.str().c_str());
  //p.initData(addMolTypeB.str().c_str());
  //p.rCutijset(0, 0, 2.);
  //p.rCutijset(0, 1, 1.75);
  //p.rCutijset(1, 1, 1.5);
  p.sig2rCut();
  p.initEnergy();
	
  // output sigmas as csv
  std::ofstream sigFile("sigFile");
  sigFile << ",sig" << endl;
  double volume = 0;
  for (int iMol = 0; iMol < nMolMax; ++iMol) {
    sigFile << iMol << "," << p.sig()[iMol] << endl;
    volume += 4./3.*PI*pow(p.sig()[iMol]/2., 3);
  }
  cout << "volume of particles: " << volume << endl;

//  const vector<double> sig = p.sig();
//  for (int i = 0; i < int(sig.size()); ++i) {
//    cout << "sig" << i << " " << sig[i] << endl;
//  }

  // initialize acceptance criteria
  CriteriaMetropolis c(beta, activ);
  // CriteriaWLTMMC c(beta, activ,"nmol",nMolMin-0.5,nMolMax+0.5,nMolMax-nMolMin+1);
  // c.activVec.push_back(exp(-3.));   //!< activity of B
  for (int iMol = 2; iMol <= nMolMax; ++iMol) {
    c.addActivity(exp(-3.));   //!< activity of B
  }
  c.pressureset(1e6);

  // initialize MC simulation object
  MC mc(&s, &p, &c);
  //WLTMMC mc(&s, &p, &c);
  mc.weight=0.8;
  transformTrial(&mc, "translate");

  // initialize number of particles
  for (int iMol = 1; iMol <= nMolMax; ++iMol) {
    cout << "iMol " << iMol << endl;
    std::stringstream addMolType;
    addMolType << "../data/data.lj" << iMol;
    mc.nMolSeek(iMol, addMolType.str().c_str());
  }

  // add other trial moves
  mc.weight=0.2;
  xswapTrial(&mc);
  mc.weight=1./3./nMolMax;
  transformTrial(&mc, "lxmod");
  transformTrial(&mc, "lymod");
  transformTrial(&mc, "lzmod");

  // output log, lnpi and movie
  mc.initLog("log", nfreq);
  // mc.initColMat("colMat", ncfreq);
  mc.setNFreqCheckE(ncfreq, 2e-4);
  mc.setNFreqTune(nfreq);
  mc.initMovie("movie", nfreq);
  mc.initXTC("movie", nfreq);
  mc.initRestart("tmp/rst", ncfreq);

  // production tmmc simulation
  mc.runNumTrials(npr);

  cout << "# MC " << s.id() << " elapsed time: " << double(clock()) / double(CLOCKS_PER_SEC) << " seconds" << endl;
}


